code needs to be able to backtrack and change things if a value cannot be plugged in.

CODE DESIGN

grid designed in cs
make logic to fill(crete the board[i][j] and its variables

random generating algorithm
    need to randomly generate a number to put in the grid\
 generate random number in random spot than use a solving algorithm to fill in the board.

    check the validity of the grid.
need to check the validity to make sure that the grid is solveable

than need to return 17 squares to the user and make it solveable for them

than need to make an error counter that keeps count of the amount of errors

finish the front end



class Solution {
    public void solveSudoku(char[][] board) {
        
        for(int i = 0;i < 9;i++) {
            HashSet<Character> row = new HashSet<>();
            for(int j = 0;j < board[i].length;j++) {
                if(board[i][j] == '.') {
                    for(int k = 1;k <= 9;k++) {
                        char current = (char)(k);
                        if(!row.add(current)) {
                            board[i][j] = current;
                            break; 
                        }   else if (k == '9'){
                            board[i][j] = '.';
                        }
                
                    }

                }

            }
        }
       return;
    }
}







finished problem 36 solution 

class Solution {
    public boolean isValidSudoku(char[][] board) {
        for(int i = 0;i < 9;i++) {
            HashSet<Character> row = new HashSet<>();
            HashSet<Character> subGrid = new HashSet<>();
            for(int j = 0;j < 9;j++) {
                HashSet<Character> column = new HashSet<>();
                //row
                if(board[i][j] != '.') {
                    if(!row.add(board[i][j])) {
                        return false;
                    } 
                    else {
                        row.add(board[i][j]);
                    }   
                }
                //columns
                if(board[j][i] != '.') {
                    if(!column.add(board[j][i])) {
                        return false;
                    } 
                    else {
                        column.add(board[j][i]);
                    }   

                }
                int subGridRow = 3 * (i / 3);
                int subGridColumn = 3 * (j / 3);
                char subGridValue = board[subGridRow + j / 3][subGridColumn + j % 3];

                if(subGridValue != '.') {
                    if(!subGrid.add(subGridValue)) {
                        return false;

                    }

                }


            }

        }
        
        return true;
    }

}

37
class Solution {
    public void solveSudoku(char[][] board) {
        
        for(int i = 0;i < 9;i++) {
            HashSet<Character> row = new HashSet<>():
            for(int j = 0;j < board[i].length;j++) {
                HashSet<Character> column = new HashSet<>();
                if(board[i][j] == '.') {
                   for(int k = 1; k <= 9;k++) {
                    board[i][j] = k;   
                    if(row.add(board[i][j])) {
                        row.add(board[i][j]);
                        break;
                    }
                    else{
                        break;
                    }
                    board[j][i] = k;
                    if(column.add(board[j][i])) {
                        column.add(board[j][i]);
                        break
                    }
                    else {
                        break;
                    }



                   }
                }




            }
        }
       return;
    }
}

// fill in number iterating loop
//check condition(if number hits 9 and no valid values are found)
//if valid iterate
//else backtrack



